{"version":3,"file":"provider.js","mappings":";AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC;AAC3D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,wBAAwB,iDAAiD;AACzE,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,CAAC;;AAED,uD","sources":["webpack://crypto-wallet-extension/./src/provider.js"],"sourcesContent":["(() => {\n  window.solana = {\n    isSolanaWallet: true,\n    publicKey: null,\n\n    async connect() {\n      try {\n        return new Promise((resolve, reject) => {\n          const timeoutId = setTimeout(() => {\n            reject(new Error('Connection request timeout'));\n          }, 30000);\n\n          const handleResponse = (event) => {\n            if (event.data.type === 'SOL_CONNECT_RESPONSE') {\n              clearTimeout(timeoutId);\n              console.log('Provider received response:', event.data);\n              window.removeEventListener('message', handleResponse);\n              \n              if (event.data.approved && event.data.publicKey) {\n                this.publicKey = event.data.publicKey;\n                resolve({ publicKey: event.data.publicKey });\n              } else {\n                const error = event.data.error || \n                  (!event.data.publicKey ? 'Please create or import a wallet first' : 'User rejected connection');\n                reject(new Error(error));\n              }\n            }\n          };\n\n          try {\n            window.addEventListener('message', handleResponse);\n            console.log('Provider sending connect request');\n            window.postMessage({ type: 'SOL_CONNECT_REQUEST' }, '*');\n          } catch (error) {\n            clearTimeout(timeoutId);\n            reject(error);\n          }\n        });\n      } catch (error) {\n        console.error('Connect error:', error);\n        throw error;\n      }\n    },\n\n    async disconnect() {\n      this.publicKey = null;\n    },\n\n    async signTransaction(transaction) {\n      return new Promise((resolve, reject) => {\n        window.postMessage({ \n          type: 'SOL_SIGN_TRANSACTION_REQUEST', \n          transaction: transaction\n        }, '*');\n\n        window.addEventListener('message', function handler(event) {\n          if (event.data.type === 'SOL_SIGN_TRANSACTION_RESPONSE') {\n            window.removeEventListener('message', handler);\n            if (event.data.approved) {\n              resolve(event.data.signedTx);\n            } else {\n              reject(new Error('User rejected transaction'));\n            }\n          }\n        });\n      });\n    },\n\n    async signMessage(message) {\n      return new Promise((resolve, reject) => {\n        window.postMessage({ \n          type: 'SOL_SIGN_MESSAGE_REQUEST', \n          message: Array.from(message)\n        }, '*');\n\n        window.addEventListener('message', function handler(event) {\n          if (event.data.type === 'SOL_SIGN_MESSAGE_RESPONSE') {\n            window.removeEventListener('message', handler);\n            if (event.data.approved) {\n              resolve({ signature: new Uint8Array(event.data.signature) });\n            } else {\n              reject(new Error('User rejected message signing'));\n            }\n          }\n        });\n      });\n    }\n  };\n})();\n\nwindow.dispatchEvent(new Event('solana#initialized')); "],"names":[],"sourceRoot":""}